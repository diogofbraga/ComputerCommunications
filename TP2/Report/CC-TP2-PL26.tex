\documentclass{llncs}
\usepackage{times}
\usepackage[T1]{fontenc}

% Comentar para not MAC Users
%\usepackage[applemac]{inputenc}

\usepackage{a4}
%\usepackage[margin=3cm,nohead]{geometry}
\usepackage{epstopdf}
\usepackage{indentfirst}
\usepackage{graphicx}
\graphicspath{{Capturas-Ecra/}}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{amsmath}
\usepackage{array}
\usepackage{courier} %% Sets font for listing as Courier.
\usepackage{listings, xcolor}
\lstset{
tabsize = 4, %% Sets tab space width.
showstringspaces = false, %% Prevents space marking in strings, string is defined as the text that is generally printed directly to the console.
numbers = left, %% Displays line numbers on the left.
commentstyle = \color{green}, %% Sets comment color.
keywordstyle = \color{blue}, %% Sets  keyword color.
stringstyle = \color{red}, %% Sets  string color.
rulecolor = \color{black}, %% Sets frame color to avoid being affected by text color.
basicstyle = \small \ttfamily , %% Sets listing font and size.
breaklines = true, %% Enables line breaking.
numberstyle = \tiny,
}
%\renewcommand{\baselinestretch}{1.5}


\begin{document}
\mainmatter
\title{TP2 - Serviço de transferência rápida e fiável de dados sobre UDP}

\titlerunning{TP2 - Serviço de transferência rápida e fiável de dados sobre UDP}

\author{Diogo Braga \and João Silva}

\authorrunning{Diogo Braga \and João Silva}

\institute{
University of Minho, Department of  Informatics, 4710-057 Braga, Portugal\\
e-mail: \{a82547,a82005\}@alunos.uminho.pt\\
PL2, Grupo 6
}

\date{}
\bibliographystyle{splncs}

\maketitle

\section{Introdução}

////////////////////////////////////// FALTA FAZER //////////////////////////////////////



\section{Especificação do protocolo}




\subsection{Formato das mensagens protolocares (PDU)}

O formato escolhido engloba aspetos que segmentos UDP por norma não incluem. Escolhemos tal abordagem para conseguir implementar uma comunicação fiável por cima dum transporte UDP. O formato escolhido é apresentado abaixo.

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
	private int sequence_number;
	private int ack_number;
	private String options;
	private boolean syn;
	private boolean fin;
	private boolean ack;
	private boolean psh;
	private int receiveWindow;
	private long checksum;
	private byte[] data;
\end{lstlisting}

Em cada \textbf{PDU} enviado estes parâmetros vão preenchidos com informação relevante para que se mantenha uma comunicação fiável, e se consiga manter um estado da comunicação. Desta forma asseguramos uma implementação dum protocolo orientado à comunicação tendo por base \textbf{UDP}.

Os campos \textbf{sequence\_number} e \textbf{ack\_number} servem para que se mantenha uma sequência no transferência dum ficheiro, e poder saber sempre se segmentos foram perdidos ou chegaram fora de ordem por exemplo.

Os campos \textbf{syn}, \textbf{fin}, \textbf{ack} e \textbf{psh} servem para identificar que tipo de segmento se trata, tendo em consideração o cabeçalho do \textbf{TCP} que contempla estes campos.

O campo \textbf{options} é usado para que sejam transferidas informações adicionais sobre a transferência dum ficheiro. É usado, por exemplo, no início da conexão para enviar o número de segmentos que o ficheiro contempla.

Usamos o campo \textbf{receiveWindow} para que trocar informação sobre o possível espaço em buffer para receber datagramas. Server para controlar o fluxo da comunicação.

O campo \textbf{data} leva todos os dados a transferir relativos ao ficheiro. Este campo tem no máximo \textbf{1024} bytes (MSS), por forma a otimizar o processo de envio tendo os segmentos relativamente curtos, para que a probabilidade de serem partidos em camadas inferiores seja reduzida.

Por último, o campo \textbf{checksum} leva um inteiro (long), relativo ao cálculo do checksum o do campo \textbf{data}.


\subsection{Interações}

\subsubsection{Início de Conexão}

Para ocorrer uma transferência de dados entre dois end-systems é necessário que exista inicialmente um estabelecimento de conexão. Quem pretende iniciar uma conexão envia um \textbf{sin} para o destino, na esperança de receber um \textbf{sinack} do servidor ao qual se liga. Seguidamente o cliente envia também um \textbf{ack} a confirmar o estabelecimento da conexão. Desta forma, com este processo tornamos a comunicação orientada à conexão, e portanto, mais controlada.

\subsubsection{Transferência de Ficheiro}

Depois de estabelecida a conexão, é realizado o envio dos dados por parte do servidor tendo em conta os parâmetros estabelecidos, como por exemplo a janela de receção de dados e o MSS. Nesta fase existe também muita interação entre os dois end-systems, pois após a tentativa de envio do servidor, o cliente têm que enviar um ack para confirmar a receção dos dados. Existe a possibilidade deste não chegar ao destino devido a congestionamentos na camada de Rede, de tal forma que nesta fase existem também retransmissões, caso necessário.

\subsubsection{Fim de Conexão}

Devido a estarmos perante uma comunicação orientada à conexão, é necessário que, depois da transferência dos dados, esta seja terminada. No nosso modelo tal acontece da seguinte forma: servidor enviar \textbf{fin} para o cliente a sinalizar que terminou a transferência dos dados; cliente responde com \textbf{finack} para sinalizar receção do fin; servidor envia \textbf{ack} para sinalizar que recebeu a confirmação do fecho da conexão do lado do cliente.



\section{Implementação}

Nesta secção optamos por fazer uma abordagem Top-Down da nossa implementação, começando pela interface com o utilizador até à classe responsável por receber e enviar datagramas pelo socket. Utilizamos a linguagem \textbf{Java} para tal tarefa.


\subsection{Interface}

A primeira fase da transferência inicia com uma interação com o software criado, tanto por parte de quem disponibiliza o ficheiro para upload (servidor), como por parte de quem tenciona descarregá-lo (cliente).

Tal interação é especificada no ficheiro \textbf{TransfereCCcmd.java}. Dependendo do que é pretendido fazer invocam-se diferentes comandos, exemplificados a seguir.

\begin{verbatim}
	>  java TransfereCCcmd -put Teste.txt
\end{verbatim}

Neste caso quem invoca o comando está a disponibilizar o ficheiro \textit{Teste.txt} para possível upload por parte de vários clientes. O utilizador terá de terminar o processo quando desejar uma vez que funciona como servidor para vários clientes e não se cinge só a uma transferência.

\begin{verbatim}
	>  java TransfereCCcmd -get Saida1.txt 10.1.1.1
\end{verbatim}

Neste caso quem invoca o comando tenciona fazer download do ficheiro que está (ou não) a ser disponibilizado por \textbf{10.1.1.1}. O ficheiro que será descarregado terá o nome \textit{Saida1.txt}.

\begin{verbatim}
	>  java TransfereCCcmd -help
\end{verbatim}

Neste caso o utilizador consulta a forma de utilização do software.


\subsection{Gestor de Transferências}

Dependendo de como o utilizador se identifica na interface (Upload ou Download) é criada uma Thread correspondente à classe \textbf{TransfereCC} que atua de diferente forma caso esteja a ser feito um Upload ou um Download. Em ambos os casos a primeira coisa a ser feita pelo \textbf{TransfereCC} é a criação duma Thread correspondente à classe \textbf{AgenteUDP}.





\section{Testes e resultados}



\section{Conclusões}



\end{document}
